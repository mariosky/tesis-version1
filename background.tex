%% La letra n con tilde es: 'n.

\chapter{Background}

This chapter present the fundamental concepts related this work. The
formal definitions referring to fuzzy systems, contextual factors and
recommender system techniques used in the proposed method.
%--------------------------------------------------------------
%Agregue la seccion de logica difusa del articulo que me mando.
\section{Production systems and fuzzy models}

\subsection{Traditional Production Systems}

Production Systems represent knowledge in form of rules, which specify
actions that will be executed when certain conditions are met. Experts
in certain domain identify a set of rules based on their experience to
resolve different kinds of problems. Also known as rule based systems,
many implementations consist mainly of these three
components \cite{brachman1992knowledge} \cite{konar2006computational}:
\begin{enumerate}   
\item \textbf{Production Rules (PR)}. A set of
production rules (also known as IF-THEN rules) having a two part
structure; the antecedent, conformed by a set of conditions and a
consequent set of actions. 
\item \textbf{Working Memory (WM)}.
Represents the current knowledge or facts that are known to be true so
far. These facts are tested by the antecedent conditions of the rules
and the consequent part can change them. 
\item \textbf{Inference Engine (IE)}. 
This interpreter matches the conditions in the
production rules with the data/instantiations found in the WM,
deriving new consequences.
\end{enumerate}
The basic operation of these systems is described as a cycle of 
three steps \cite{brachman1992knowledge}:
\begin{enumerate}
\item \textbf{Recognize}: Find which rules are satisfied by 
the current WM. The antecedent part of the productions consists 
of a set of clauses connected by AND operators, when all these 
clauses have matching data on the WM the production has a chance 
of firing.
\item \textbf{Conflict Resolution}: Only one production can be 
fired at a time, so when two or more rules can be fired concurrently 
a conflict occurs. Among the production rules found in the first 
step, choose which rules should fire.
\item \textbf{Actions}: Change the working memory by performing 
the actions specified in the consequent part of all the rules 
selected in the second step. Changes occur by adding or 
deleting elements of the WM.
\end{enumerate}

This cycle continues until no further production rules can be fired.
This control strategy is data driven because whenever the antecedent
part is satisfied the rule is recognized, this strategy is also named
chain-forward. Other strategy is chain-backward in this case the work
is done from the conclusion to the facts, to chain-backward, goals in
working memory are match against consequents of the production
rules.\\  A drawback that has been recognized in these traditional
productions systems, is that some times rules are not fired in the
Recognize step because no appropriate match exists in the WM. Partial
matching of rules is not possible and this can be a limitation in some
systems because premature termination of the cycle is not desired. An
approach to handle partial matching is using fuzzy logic
\cite{konar2006computational}. In the next section a review of the
extension of production systems with fuzzy logic is preasented.\\

\subsection{Fuzzy Production Rules}

Fuzzy production rules use fuzzy logic sets to characterize the
variables and terms used in the propositions of the rules. Fuzzy
production rules or fuzzy \textit{IF-THEN} rules are expressions of
the form \textit{IF} antecedent \textit{THEN} consequent, where the
antecedent is a proposition of the form \textit{"x is A"} where
\textit{x} is a linguistic variable and \textit{A} is a linguistic
term. The truth value of this proposition is based on the matching
degree between \textit{x} and \textit{A}. Propositions are connected
by \textit{AND}, \textit{OR} and \textit{NOT} operators. Some
implementations of fuzzy rule-based systems also include other kinds
of data types in their propositions, for example the FLOPS system
includes fuzzy numbers, hedges, and non fuzzy data types (integers,
strings and float) \cite{siler2005fuzzy}. Depending on the form of the
consequent, two main types of fuzzy production systems are
distinguished \cite{babuvska1996fuzzy}:
\begin{itemize}  
\item \textbf{Linguistic fuzzy model}: where both the antecedent 
and consequent are fuzzy propositions.
\item \textbf{Takagi-Sugeno fuzzy model}: the antecedent is a fuzzy 
proposition; the consequent is a crisp function.
\end{itemize}  
As before, other non-fuzzy consequents can also be implemented, like
the execution of commands or the addition of new data.\\
\textbf{Linguistic Variables (LV)} are variables that can be assigned
linguistic terms as values, i.e. if we define a linguistic variable
\textit{SPEED} we can assign it the linguistic terms \textit{SLOW},
\textit{MEDIUM} or \textit{FAST}. The meaning of these linguistic
terms is defined by their membership functions (MF). \textit{LV} can
be defined as a \textit{5-tuple} \textit{LV=}$<v,T,X,g,m>$ where
\textit{v} is the name of the variable, \textit{T} is the set of
linguistic terms of \textit{v, X} is the domain (universe) of
\textit{v,g} is a syntactic rule to generate linguistic terms,
\textit{m} is a semantic rule that assigns to each term \textit{t} its
meaning \textit{m(t)}, which is a fuzzy set defined in \textit{X}.

\subsection{Fuzzy Inference Systems}

\textit{Fuzzy Inference Systems} (FISs) also called \textit{Fuzzy
Models} are fuzzy production systems used for modeling input-output
relationships. From this input-output view, Babuŝka
\cite{babuvska1996fuzzy} describes these systems as \textit{"flexible
mathematical functions which can approximate other functions or just
data (measurements) with a desired accuracy"}. Fuzzy Productions Rules
define the relationship between input and output variables. Input
variables are defined in the antecedent part of the rule and the
consequent part defines the output variables. These FIS are used
mainly in control systems, and are basically composed of five
modules\cite{babuvska1996fuzzy}:
\begin{enumerate}  
\item \textbf{Rule Base.} The set of fuzzy production rules.
\item \textbf{Database.} Where the membership functions are defined.
\item \textbf{Fuzzy Inference Engine.} This module executes the 
fuzzy inference operations.
\item \textbf{Fuzzifier.} This interface transforms the inputs 
of the systems (numerical data) into linguistic values.
\item \textbf{Defuzzifier.} This interface transforms the fuzzy 
results into numerical data.
\end{enumerate}
Usually the Rule Base and Data Base modules are collectively 
called the Knowledge Base module. The steps involved in fuzzy 
inference in a FIS are \cite{dubois1980fuzzy}:
\begin{enumerate} 
\item Compare the input variables with the membership functions 
in the antecedent, to obtain the membership values of each 
linguistic term. This step is frequently called fuzzification.
\item Compose through a specific T-Norm operator (mainly max-min 
or max-product) the membership values to obtain the degree of 
support of each rule.
\item Generate the qualified consequence (fuzzy or numeric) of 
each rule depending on the degrees of support. These outputs 
are then aggregated to form a unified output.
\item Then the output fuzzy set is resolved or defuzzified 
to a single numeric value.
\end{enumerate} 
Three main inference systems can be described:
\begin{itemize} 
\item \textbf{Tsakumoto}: The output is the average of the 
weights of each rule numeric output, induced by the degree of 
support of each rule, the min-max or min-product with the 
antecedent and the membership functions of the output. The 
membership functions used in this method must be 
non-decrease monotonic. 
\item \textbf{Mamdani}: The output is calculated by applying 
the min-max operator to the fuzzy output (each equal to the 
minimum support degree and the membership function of the rule). 
Several schemes have been proposed to choose the numeric output 
based on the fuzzy output; these include the centroid area, 
area bisection, maximum mean, maximum criteria.
\item \textbf{Sugeno}: The fuzzy production rules are used. The 
output of each rule is a linear combination of the input 
variables plus a constant term, and the output is the average 
of the support degree of each rule.
\end{itemize} 

\section{Context}
%%
%% Escribe aquí una intro general de contexto,
%% antes de ver especificamente al contexto en SR 
%% Context y Contextual Information son dos términos distintos
%% Context es el contexto real y de este se extrae información contextual.
%% A veces los usas como si fuera lo mismo. 

%% También debes definir Contextual Factors, creo que es 
%% Información Contextual que puede afectar a la recomendación   

The application of contextual information in recommender systems, there are %
previous approaches by assuming the existence of certain contextual         % Mejorar
factors, such as time, location, and the purchasing purpose, that
identify the context in which recommendations are provided. An
assumption for each of these contextual factors can have a structure;
the time factor, for instance, it can be defined in terms of seconds,
minutes, hours, days, months, and years. The classification of context 
%Segura que es la clasificacion de context?
%Este parrafo es incorrecto
%La enumeración no es una clasificación 
that is proposed by Adomavicious\cite{adomavicius2011context} is based on the 
following two aspects of contextual factors: 1) what a RS may know
about these contextual factors and, 2) how contextual factors change
over time.
\begin{enumerate}

%% Este parrafo repite habla de la clasificación, no es una clasificación
\item \textbf{What a recommender system may know about these contextual factors.} 
A recommender system can have different types of knowledge, which may include 
the exact list of all the relevant factors, their structure, and their values, 
about the contextual factors. Depending on what exactly the system knows (that 
is, what is being observed), it can classify the knowledge of a recommender 
system about the contextual factors into three categories: 
	%% Entonces se clasifican en tres:
	\begin{itemize}
	\item \textbf{Fully observable}: The contextual factors relevant to the 
	application, as well as their structure and their values at the time when 
	recommendations are made, are known explicitly. For example, when
	recommending the purchase of a certain product, like a shirt, the 
	recommender system may know only the \tt{Time}, PurchasingPurpose, and  %% Ponlos como \tt{}
	ShoppingCompanion factors matter in this application. Further, the 
	recommender system may know the structure of all these three contextual 
	factors, such as having categories of weekday, weekend, and holiday for 
	Time. Further, the recommender system may also know the values of the 
	contextual factors at the recommendation time (for example, when this 
	purchase is made, with whom, and for whom).
	\item \textbf{Partially observable}: Only some of the information about 
	the contextual factors described above, is explicitly known. For example, 
	the recommender system may know all the contextual factors, such as Time, 
	PurchasingPurpose, and ShoppingCompanion, but not their structure. Note that 
	there can possibly be different levels of “partial observability.” In this 
	article we do not differentiate between them and group various cases of 
	partially observable knowledge into this general category.
	\item \textbf{Unobservable}: No information about contextual factors is 
	explicitly available to the recommender system, and it makes recommendations 
	by utilizing only the latent knowledge of context in an implicit manner. 
	For example, the recommender system may build a latent predictive model, 
	such as hierarchical linear or hidden Markov models, to estimate unknown 
	ratings, where unobservable context is modeled using latent variables.
	\end{itemize}
\item \textbf{How contextual factors change over time.} Depending on whether 
contextual factors change over time or not, there are two categories: 
	\begin{itemize}
	\item \textbf{Static}: The relevant contextual factors and their structure
	remains the same (stable) over time. For example, in case of recommending a
	purchase of a certain product, such as a shirt, we can include the
	contextual factors of Time, PurchasingPurpose, ShoppingCompanion and only
	them during the entire lifespan of the purchasing recommendation
	application.
	\item \textbf {Dynamic}: This is the case when the contextual factors change in 
	some way. For example, the recommender system (or the system designer) may 
	realize over time that the ShoppingCompanion factor is no longer relevant for 
	purchasing recommendations and may decide to drop it. Furthermore, the structure 
	of some of the contextual factors can change over time (for example, new 
	categories can be added to the PurchasingPurpose contextual factor over time).
	\end{itemize}
\end{enumerate} 
On the other hand, Fling\cite{fling2009mobile} considers four types of context that 
can be used by different applications:  %Creo que estos pueden ser factores, no contextos 
\begin{itemize} 
\item \textbf{Physical context}: representing the time, position, and activity 
of the user, but also the weather, light, and temperature when the 
recommendation is supposed to be used. 
\item \textbf{Social context}: representing the presence
and role of other people (either using or not using the application) around the
user and whether the user is alone or in a group when using the application.
\item \textbf{Interaction media context}: describing the device used to access
the system (for example, a mobile phone or a kiosk) as well as the type of media
that are browsed and personalized. The latter can be ordinary text, music,
images, movies, or queries made to the recommender system. 
\item \textbf{Modal context}: representing the current state of mind of the user, 
the user’s goals, mood, experience, and cognitive capabilities.  
\end{itemize}
The contexts classification reachs to a general context definition %No se si llamarle clasificacion
adopted like the most suitable definition proposed by A. K. Dey  and it
was mentioned in chapter 1.\\ 

%% Esta idea es tuya? Creo que yo no llamaría a esto context más bien algo como context factor  
Then, an example to explain context is considering a context-aware
application, an indoor mobile tour guide. Here, the
entities are the user, the application and the tour sites.  We will
look at two pieces of information – weather and the presence of other
people – and use the definition to determine if either one is context.
The weather does not affect the application because it is being used
indoors. Therefore, it is not context. The presence of other people,
however, can be used to characterize the user’s situation. If a user
is traveling with other people, then the sites that they visit may are
the points of interest for the user. Therefore, the presence of other
people is context because it can be used to characterize the user’s
situation. \\ 
%Falta afinar el siguiente párrafo:
Previously understanding the context, it is likely to define \textbf
{context-aware recommender systems}, it is viable to adopt the
definition of \textbf{A. K. Dey et.al}\cite{dey2001understanding} to
formalize what features it has a Context-aware recommender
system:\textit{``a system is context-aware if it uses context to
provide relevant information and/or services  to the user, where
relevancy depends on the user’s task."} \\  This definition is closer
to the real about behaviour of \textbf{context-aware recommender
system} when it incorporates contextual information to get
recommendations,  in addition, is fewer confused and specific than
other author's definitions.

\section{Recommender systems}

\subsection{Collaborative Filtering algorithm}
The idea behind collaborative recommendation approaches is to exploit
information about past behavior or opinions of an exisiting user community 
for predicting which items certain user of the
system will most probably like or be interested in
\cite{anIntroduction}. Recommender systems are useful in several types
of  applications, however, their biggest impact has been mainly in ecommerce 
web sites in order to  personalize the information for a particular user as
the system can help to promote several items of his or her interest, thus increasing the sales
of the on-line store. In traditional implementations a Collaborative Filtering (CF)
algorithm takes as input a given \textit{user-item} matrix of ratings 
to generate a prediction for each item-user pair indicating to what degree
the current user will like or
dislike an item. Subsequently with that information 
a list of the top \textit{n} recommended 
items for the user can be generated. The generated list contains 
only those items that have not been reviewed by the user.
Differents approaches are utilized for CF such
as:  a) user-based nearest neighbor recommendation, b) Item-based
nearest neighbor  recommendation and c) model-based recommendation.\\
a) \textit{User-based nearest neighbor} is approach the is used the most because
is relatibly easy to implement and offers acceptable results. Another advantage
is tha only the rating matrix is needed to obtain recommendations. 
The neighborhood selection consists in taking the \textit{k} 
nearest neighbors into account usind the threshold to define 
the size of the neighborhood. A neigborhood of small can not make accurate 
predictions, and on the other hand if the
neighborhood is too large the information about the nighbours could not be
significant.\\ To obtain the similarity value between a user and his 
neighbors, the Pearson correlations measure is commonly used, taking the values from
$+1$ (strong positive correlation) to $-1$ (strong negative
correlation) to define how similar a neighbor is. The similarity
$sim(a,b)$ of users $a$ and $b$, given the rating matrix $R$ is
denoted by the following equation:
\begin{equation}\label{eq:pearson1}
\displaystyle sim(a,b) = {\sum_{p \in P}(r_{a,p} - 
\bar{r_a})(r_{b,p}- \bar{r_b}) 
\over \sqrt{\sum_{p \in P}(r_{a,p} - \bar{r_a})^2} 
\sqrt{\sum_{p \in P} 
(r_{b,p}- \bar{r_b})^2}}
\end{equation}
Where the symbol $\bar{r_a}$ corresponds to the average rating of user
$a$. Subsequently, a formula to calculate the prediction of the user
$a$ for item $p$ that also factors the relative proximity of the
nearest neighbors $N$ and $a's$ average rating $\bar{r_a}$ is denoted
by the following equation:
\begin{equation}\label{eq:prediction}
\displaystyle pred(a,b) = \bar{r_a} + 
{\sum_{b \in N} sim(a,b) * (r_{b,p}- \bar{r_b}) 
\over \sum_{b \in N} sim(a,b)} 
\end{equation}
b) \textit{Item-based nearest neighbor} is the same idea than the \textit
{user-based}, the difference is that this approach tries to find
similar items instead of similar users to make a prediction using the rating
matrix.  Then, in a \textit{item-based} recommendation is to compute
predictions using the similarity between items and not the similarity
between users.  To find similar items cosine similarity measure is
defined, this metric measures the similarity between two
\textit{n-dimensional} vectors based on the angle between them.
Therefore, the similarity between two items \textit{a} and \textit{b}
– viewed as the corresponding rating vectors $a$ and $b$ – is formally
defined as follows:
\begin{equation}\label{eq:cosine}
\displaystyle sim(\overrightarrow{a},\overrightarrow{b})= 
{\overrightarrow{a}* \overrightarrow{b} \over
|\overrightarrow{a}|*|\overrightarrow{b}| }
\end{equation}
The * symbol is the dot product of vectors. $|a|$ is the Euclidian
length of the vector, which is defined as the square root of the dot
product of the vector with itself.\\ 
c) \textit{Model-based approach}, in this technique  the raw data are
first processed offline, as described for \textit {item-based}
filtering or some dimensionality reduction techniques. At run time,
only the learned model is required to make predictions. Although
\textit{memory-based} approach is theoretically more precise because
full data is available for generating recommendations, such systems
face problems of scalability when databases of tens of millions of
users and items are used. An example of this approach is matrix
factorization or latent factors model, normally used to fill a rating
matrix to calculate predictions taking in account the latent factors.

\subsection{Content-based algorithm}

In content-based the recommendation task then consists of determining the
items that match the user’s preferences best. Although such an approach must
rely on additional information about items and user preferences, it does not
require the existence of a large user community or a rating history –that is,
recommendation lists can be generated even if there is only one single user. In
practical settings, technical descriptions of the features and characteristics
of an item– such as the genre of a book or the list of actors in a movie – are
more often available in electronic form, as they are partially already provided
by the providers or manufacturers of the goods. What remains challenging,
however, is the acquisition of subjective, qualitative features. In domains of
quality and taste, for example, the reasons that someone likes something are not
always related to certain product characteristics and may be based on a
subjective impression of the item’s exterior design.   \\
\textbf{Content representation.} The simplest way to describe catalog items is
to maintain an explicit list of features for each item (also often called
attributes, characteristics, or item profiles). For a book recommender, one
could, for instance, use the genre, the author’s name, the publisher, or
anything else that describes the item and store his information in a relational
database system. When the user’s preferences are described in terms of his or
her interests using exactly this set of features, the recommendation task
consists of matching item characteristics and user preferences.  \\
\textbf{Vector space model.}  Content-based systems have historically been
developed to filter and recommend text-based items such as e-mail messages or
news. The standard approach in CB recommendation is, therefore, not to maintain
a list of \textit{meta-information features}, but to use a list of relevant keywords
that appear within the document. The main idea, of course, is that such a list
can be generated automatically from the document content itself or from a 
free-text description thereof.

\subsection{Hybrid recommender systems} 

Each recommender system technique has its pros and cons – for
instance, the ability to handle data sparsity and cold-start problems
or considerable efforts for knowledge acquisition and engineering. \\ 
User models and contextual information, community and
product data, and knowledge models constitute the potential types of
recommendation input. However, none of the basic approaches is able to
fully exploit all of these. Consequently, building hybrid systems that
combine the strengths of different algorithms and models to overcome
some of the afore mentioned shortcomings and problems has become the
target of recent research. Hybrid recommender systems are technical
approaches that combine several algorithms or recommendation components.

\subsection{Context-aware recommender systems}

Traditionally, the recommendation problem has been viewed as a prediction
problem in which, given a user profile and a target item, the recommender
system’s task is to predict that user’s rating or that item, reflecting the
degree of user’s preference for that item. \\  Specifically, a recommender system
tries to estimate a rating function:  $R$ : $Users * Items$ $ 
\leftarrow Ratings$, that maps \textit{user-item} pairs to an ordered 
set of rating values.\\ 
In contrast to the traditional model, context-aware recommender system tries to
incorporate or utilize additional evidence (beyond information about users and
items) to estimate user preferences on unseen items. \\ When such contextual
evidence can be incorporated as part of the input to the recommender systems,
the rating function can be viewed as  \textit{multidimensional}: $R$ : $Users *
Items * Contexts$ $ \leftarrow Ratings$, where \textbf{contexts} represents a set of
factors that further delineate the conditions under which the \textit{user-item}
pair is assigned a particular rating. \\ The underlying assumption of this extended
model is that user preferences for items are not only a function of items
themselves, but also a function of the context in which items are being
considered\cite{lim2009assessing}.

\subsection{Paradigms}

When recommender system uses the contextual information, it starts
with the data having the form \textit{U * I * C * R}, where \textit{C}
is additional contextual   dimension and end up with a list of
contextual recommendations  $i_{1}$,$i_{2}$,$i_{3}$...$i_{n}$ for each
user. However, when the recommendation process does not take into
account  the contextual information, is posible to apply the
information about the current (or desired) context \textit{c} in
various stages of the recommendation process.  Adomavicious defines
three paradigms to the context-aware recommendation process that is
based on contextual user preference:

\begin{itemize}
\item  \textbf{Contextual pre-filtering (or contextualization of
recommendation input).} In this recommendation paradigm, contextual
information drives data selection or data construction for that specific
context. In other words, information about the current context c is used for
selecting or constructing the relevant set of data records (i.e., ratings).
Then, ratings can be predicted using any traditional 2D recommender system 
on the selected data.   	
\item \textbf{Contextual post-filtering (or contextualization of recommendation
output).} In this recommendation paradigm, contextual information is initially
ignored, and the ratings are predicted using any traditional 2D recommender
system on the entire data. Then, the resulting set of recommendations is
adjusted (contextualized) for each user using the contextual information.
\item \textbf{Contextual modeling (or contextualization of recommendation
function).} In this recommendation paradigm, contextual information is used
directly in the modeling technique as part of rating estimation.
\end{itemize}



